

# 函数嵌套

def fn1():
    print("fn1")

    def fn2():
        print("fn2")

    return fn2

# fn1()
# fn2()  # 报错

res = fn1()  # res = fn2
res()  # fn2()

fn1()()


# 传参
def f1(a):
    print('f1')

    def f2(b):
        print('f2:', a, b)
    return f2

res = f1(3)
res(4)

f1(5)(6)


# 局部变量： 不会被污染， 内存会被回收
def m1():
    a = 10
    print(a)
m1()
# print(a)  # 报错


# 垃圾回收机制：GC
# 值类型：
#   定义值类型的变量，如：a=10，系统会标记a变量的使用范围,标记'yes'表示正在使用,
#   当超出作用范围后，将变量标记为'no', 系统的垃圾回收机制会在某个时刻就会将标记
#   为‘no’的变量所占的内存清除
# 引用类型：
#   定义引用类型的变量时，如：l=[1,2], 利用引用计数，此时的引用计数是1
#   如果有其他变量也指向该列表，如:m=l; 引用计数+1, 只有当引用计数为0时才会把内存释放.

# l = [1, 2]  # 引用计数1，1表示有一个变量正在使用
# m = l  # 引用计数+1，变成2；2表示有两个变量正在使用
# m = 10  # 引用计数-1，变成1；
# l = 20  # 引用计数-1，变成0, 此时列表所占的内存会被系统回收

# 全局变量: 可能会被污染, 内存不会被回收
b = 20
def m2():
    print(b)

# print(b)
m2()
b = 30
m2()


#
# 局部变量：不会被污染， 内存会被回收
# 全局变量: 可能会被污染, 内存不会被回收

# 闭包：不会被污染，内存不会被回收
#   函数嵌套函数，内部函数使用了外部函数的变量或参数，要把内部函数返回,
#   那么这个变量或参数就不会被释放，这种机制就叫闭包
c = 20  # global变量
def fun1():
    c = 10

    def fun2():
        # global c  # 使用 c=20 这个变量
        nonlocal c  # 使用 c=10 这个变量
        c += 1
        print("fun2, c =", c)
    return fun2

res = fun1()
res()  # 10
res()  # 10
res()  # 10

#
def fx(x, y):
    def fy(n):
        return n*x + y
    return fy

f = fx(3, 5)  # f(n) = 3n + 5
print(f(2))  # fy(2) = 2*x + y
print(f(3))  # 3x+y

f2 = fx(6, 8)  # f(n) = 6n + 8
print(f2(2))  # 2x+y


